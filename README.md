# Advent of Code 2025

My solutions for [Advent of Code 2025](https://adventofcode.com/2025) written in Elixir.

This project serves as a test of **Claude Sonnet 4**'s code generation capabilities for Elixir. All solutions are generated by Claude to evaluate the quality and effectiveness of AI-assisted Elixir development.

## Setup

This project requires Elixir 1.18+ and Mix.

```bash
# Clone the repository
git clone https://github.com/claytonflesher/advent_of_code_2025.git
cd advent_of_code_2025

# Install dependencies
mix deps.get

# Run tests
mix test

# Run a specific day's solution
mix run -e "IO.puts(AdventOfCode2025.Day01.part1(AdventOfCode2025.Day01.read_input()))"
```

## Project Structure

```
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ advent_of_code2025.ex    # Main module
â”‚   â””â”€â”€ day01.ex                 # Day 1 solution
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ advent_of_code2025_test.exs
â”‚   â””â”€â”€ day01_test.exs           # Day 1 tests
â”œâ”€â”€ inputs/
â”‚   â””â”€â”€ day01.txt                # Day 1 puzzle input
â””â”€â”€ mix.exs                      # Project configuration
```

## Solutions

| Day | Part 1 | Part 2 | Notes |
|-----|--------|--------|-------|
| [01](lib/day01.ex) | â­ | â­ | Safe dial rotation simulation |
| [02](lib/day02.ex) | â­ | â­ | Gift shop invalid product IDs |
| [03](lib/day03.ex) | â­ | â­ | Battery bank joltage optimization |
| [04](lib/day04.ex) | â­ | â­ | Forklift paper roll accessibility |
| [05](lib/day05.ex) | â­ | â­ | Fresh ingredient ID range analysis |
| [06](lib/day06.ex) | â­ | â­ | Cephalopod math worksheet problems |
| [07](lib/day07.ex) | ğŸ”’ | ğŸ”’ | Ready to implement |
| [08](lib/day08.ex) | ğŸ”’ | ğŸ”’ | Ready to implement |
| [09](lib/day09.ex) | ğŸ”’ | ğŸ”’ | Ready to implement |
| [10](lib/day10.ex) | ğŸ”’ | ğŸ”’ | Ready to implement |
| [11](lib/day11.ex) | ğŸ”’ | ğŸ”’ | Ready to implement |
| [12](lib/day12.ex) | ğŸ”’ | ğŸ”’ | Ready to implement |

**Total Stars: â­â­â­â­â­â­â­â­â­â­â­â­ (12/48)**

### Day 1: Secret Entrance

**Problem**: Simulate a safe dial with rotations and count when it points to 0.

- **Part 1**: Count how many times the dial ends at position 0 after rotations
- **Part 2**: Count every click that causes the dial to point at 0 (including during rotations)

**Key insights**:
- Dial positions are 0-99 in a circle (modular arithmetic)
- Part 2 requires tracking intermediate positions during each rotation
- Large rotations can pass through 0 multiple times

### Day 2: Gift Shop

**Problem**: Detect invalid product IDs based on repeated character patterns.

- **Part 1**: Count IDs with exact repetitions (same character, same count)
- **Part 2**: Count IDs with flexible repetitions (same character, any count â‰¥ original)

### Day 3: Lobby

**Problem**: Optimize battery bank configurations to maximize joltage output.

- **Part 1**: Select exactly 2 batteries from each bank to maximize 2-digit joltage
- **Part 2**: Select exactly 12 batteries from each bank to maximize 12-digit joltage

**Key insights**:
- Part 1 uses combinatorial search for small selections
- Part 2 uses greedy "remove k digits" algorithm for efficiency
- Maintaining positional order is crucial for maximizing numerical value

### Day 4: Printing Department

**Problem**: Optimize forklift operations by identifying accessible paper rolls.

- **Part 1**: Count paper rolls with fewer than 4 adjacent rolls (accessible by forklifts)
- **Part 2**: Simulate iterative removal of accessible rolls until no more can be removed

**Key insights**:
- Grid-based neighbor counting in 8 directions
- Iterative simulation with cascading effects
- Efficient position-based grid representation as maps

### Day 5: Cafeteria

**Problem**: Analyze ingredient freshness using ID ranges and databases.

- **Part 1**: Count available ingredient IDs that fall within fresh ingredient ranges
- **Part 2**: Calculate total count of all ingredient IDs covered by fresh ranges

**Key insights**:
- Range intersection and membership testing
- Merging overlapping ranges to avoid double-counting
- Efficient range arithmetic for large number spaces
- Algorithm scales from 15-digit sample banks to 100-digit actual input

### Day 6: Trash Compactor

**Problem**: Solve cephalopod math worksheets with column-based number arrangements.

- **Part 1**: Parse problems arranged vertically in columns, solve with standard math
- **Part 2**: Apply cephalopod math - read columns right-to-left, numbers formed by character positions

**Key insights**:
- Column detection using space-separated boundaries  
- Character position-based parsing for Part 2
- Right-to-left problem ordering with top-to-bottom digit reading
- Same input, different interpretation between parts

## Running Solutions

Each day's module follows the same pattern:

```elixir
# Run part 1
AdventOfCode2025.Day01.part1(AdventOfCode2025.Day01.read_input())

# Run part 2  
AdventOfCode2025.Day01.part2(AdventOfCode2025.Day01.read_input())

# Test with sample input
AdventOfCode2025.Day01.part1("L68\nL30\nR48\n...")
```

## Testing

```bash
# Run all tests
mix test

# Run tests for a specific day
mix test test/day01_test.exs

# Run tests with verbose output
mix test --trace
```

## Adding New Days

Each day follows a consistent structure:

1. Create `lib/dayXX.ex` with the solution module
2. Create `test/dayXX_test.exs` with tests
3. Add input file to `inputs/dayXX.txt`
4. Update this README

## License

This project is open source and available under the [MIT License](LICENSE).

