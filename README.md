# Advent of Code 2025

My solutions for [Advent of Code 2025](https://adventofcode.com/2025) written in Elixir.

This project serves as a test of **Claude Sonnet 4**'s code generation capabilities for Elixir. All solutions are generated by Claude to evaluate the quality and effectiveness of AI-assisted Elixir development.

## Setup

This project requires Elixir 1.18+ and Mix.

```bash
# Clone the repository
git clone https://github.com/claytonflesher/advent_of_code_2025.git
cd advent_of_code_2025

# Install dependencies
mix deps.get

# Run tests
mix test

# Run a specific day's solution
mix run -e "IO.puts(AdventOfCode2025.Day01.part1(AdventOfCode2025.Day01.read_input()))"
```

## Project Structure

```
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ advent_of_code2025.ex    # Main module
‚îÇ   ‚îî‚îÄ‚îÄ day01.ex                 # Day 1 solution
‚îú‚îÄ‚îÄ test/
‚îÇ   ‚îú‚îÄ‚îÄ advent_of_code2025_test.exs
‚îÇ   ‚îî‚îÄ‚îÄ day01_test.exs           # Day 1 tests
‚îú‚îÄ‚îÄ inputs/
‚îÇ   ‚îî‚îÄ‚îÄ day01.txt                # Day 1 puzzle input
‚îî‚îÄ‚îÄ mix.exs                      # Project configuration
```

## Solutions

| Day | Part 1 | Part 2 | Notes |
|-----|--------|--------|-------|
| [01](lib/day01.ex) | ‚≠ê | ‚≠ê | Safe dial rotation simulation |
| [02](lib/day02.ex) | ‚≠ê | ‚≠ê | Gift shop invalid product IDs |
| [03](lib/day03.ex) | ‚≠ê | ‚≠ê | Battery bank joltage optimization |
| [04](lib/day04.ex) | ‚≠ê | ‚≠ê | Forklift paper roll accessibility |
| [05](lib/day05.ex) | ‚≠ê | ‚≠ê | Fresh ingredient ID range analysis |
| [06](lib/day06.ex) | ‚≠ê | ‚≠ê | Cephalopod math worksheet problems |
| [07](lib/day07.ex) | ‚≠ê | ‚≠ê | Quantum tachyon manifold beam splitting |
| [08](lib/day08.ex) | ‚≠ê | ‚≠ê | Playground junction box circuit building |
| [09](lib/day09.ex) | ‚≠ê | ‚≠ê | Movie theater red/green tile rectangles |
| [10](lib/day10.ex) | ‚≠ê | ‚≠ê | Factory joltage counter calibration |
| 11 | üîí | üîí | Unlocks December 11 |

**Total Stars: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (20/24)**

### Day 1: Secret Entrance

**Problem**: Simulate a safe dial with rotations and count when it points to 0.

- **Part 1**: Count how many times the dial ends at position 0 after rotations
- **Part 2**: Count every click that causes the dial to point at 0 (including during rotations)

**Key insights**:
- Dial positions are 0-99 in a circle (modular arithmetic)
- Part 2 requires tracking intermediate positions during each rotation
- Large rotations can pass through 0 multiple times

### Day 2: Gift Shop

**Problem**: Detect invalid product IDs based on repeated character patterns.

- **Part 1**: Count IDs with exact repetitions (same character, same count)
- **Part 2**: Count IDs with flexible repetitions (same character, any count ‚â• original)

### Day 3: Lobby

**Problem**: Optimize battery bank configurations to maximize joltage output.

- **Part 1**: Select exactly 2 batteries from each bank to maximize 2-digit joltage
- **Part 2**: Select exactly 12 batteries from each bank to maximize 12-digit joltage

**Key insights**:
- Part 1 uses combinatorial search for small selections
- Part 2 uses greedy "remove k digits" algorithm for efficiency
- Maintaining positional order is crucial for maximizing numerical value

### Day 4: Printing Department

**Problem**: Optimize forklift operations by identifying accessible paper rolls.

- **Part 1**: Count paper rolls with fewer than 4 adjacent rolls (accessible by forklifts)
- **Part 2**: Simulate iterative removal of accessible rolls until no more can be removed

**Key insights**:
- Grid-based neighbor counting in 8 directions
- Iterative simulation with cascading effects
- Efficient position-based grid representation as maps

### Day 5: Cafeteria

**Problem**: Analyze ingredient freshness using ID ranges and databases.

- **Part 1**: Count available ingredient IDs that fall within fresh ingredient ranges
- **Part 2**: Calculate total count of all ingredient IDs covered by fresh ranges

**Key insights**:
- Range intersection and membership testing
- Merging overlapping ranges to avoid double-counting
- Efficient range arithmetic for large number spaces
- Algorithm scales from 15-digit sample banks to 100-digit actual input

### Day 6: Trash Compactor

**Problem**: Solve cephalopod math worksheets with column-based number arrangements.

- **Part 1**: Parse problems arranged vertically in columns, solve with standard math
- **Part 2**: Apply cephalopod math - read columns right-to-left, numbers formed by character positions

**Key insights**:
- Column detection using space-separated boundaries  
- Character position-based parsing for Part 2
- Right-to-left problem ordering with top-to-bottom digit reading
- Same input, different interpretation between parts

### Day 7: Laboratories

**Problem**: Simulate tachyon beam splitting through a manifold with splitters.

- **Part 1**: Count the number of beam splits when beams hit splitters (^)
- **Part 2**: Count quantum timelines using many-worlds interpretation

**Key insights**:
- Tachyon beams move downward and split at splitters into left/right beams
- Part 1 tracks splitter activations to count total splits
- Part 2 uses memoization to handle exponential timeline growth efficiently
- Quantum particles create two timelines at each splitter (left and right paths)

### Day 8: Playground

**Problem**: Build circuits connecting components in a junction box using wires.

- **Part 1**: Count connected components (islands) in the wiring diagram
- **Part 2**: Find longest path through the circuit from start to end

### Day 9: Movie Theater

**Problem**: Find the largest rectangle using red tiles as corners on a theater floor.

- **Part 1**: Find largest rectangle using any two red tiles as opposite corners
- **Part 2**: Find largest rectangle where all tiles are red or green (connected by green paths)

**Key insights**:
- Red tiles form a closed rectilinear polygon with green connection tiles between them
- Part 1 uses simple area calculation with inclusive bounds
- Part 2 uses polygon edge crossing detection to efficiently filter valid rectangles
- For large inputs, checking if polygon edges cross the rectangle interior is much faster than checking every tile

### Day 10: Factory

**Problem**: Find minimum button presses to calibrate joltage counters on factory machines.

- **Part 1**: Count all lights that are ON after toggling sequences
- **Part 2**: Minimize total button presses to reach target joltage values

**Key insights**:
- Part 2 is an Integer Linear Programming problem: minimize Œ£x·µ¢ subject to Ax = b, x ‚â• 0
- Gauss-Jordan elimination reduces the system to RREF, identifying pivot and free variables
- Branch-and-bound search explores free variable assignments with pruning
- Parallel processing using `Task.async_stream` speeds up multi-machine solving
- Rational arithmetic avoids floating-point precision issues

## Running Solutions

Each day's module follows the same pattern:

```elixir
# Run part 1
AdventOfCode2025.Day01.part1(AdventOfCode2025.Day01.read_input())

# Run part 2  
AdventOfCode2025.Day01.part2(AdventOfCode2025.Day01.read_input())

# Test with sample input
AdventOfCode2025.Day01.part1("L68\nL30\nR48\n...")
```

## Testing

```bash
# Run all tests
mix test

# Run tests for a specific day
mix test test/day01_test.exs

# Run tests with verbose output
mix test --trace
```

## Adding New Days

Each day follows a consistent structure:

1. Create `lib/dayXX.ex` with the solution module
2. Create `test/dayXX_test.exs` with tests
3. Add input file to `inputs/dayXX.txt`
4. Update this README

## License

This project is open source and available under the [MIT License](LICENSE).

